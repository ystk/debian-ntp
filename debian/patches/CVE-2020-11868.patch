--- ntp-4.2.6.p5+dfsg.orig/ntpd/ntp_proto.c
+++ ntp-4.2.6.p5+dfsg/ntpd/ntp_proto.c
@@ -1338,9 +1338,17 @@ receive(
 	/*
 	 * The dance is complete and the flash bits have been lit. Toss
 	 * the packet over the fence for processing, which may light up
-	 * more flashers.
+	 * more flashers. Leave if the package is not good.
 	 */
 	process_packet(peer, pkt, rbufp->recv_length);
+       if (peer->flash & PKT_TEST_MASK)
+		return;
+
+	/* [bug 3592] Update poll. Ideally this should not happen in a
+	* receive branch, but too much is going on here... at least we
+	* do it only if the packet was good!
+	*/     
+       poll_update(peer, peer->hpoll);
 
 	/*
 	 * In interleaved mode update the state variables. Also adjust the
@@ -1424,7 +1432,6 @@ process_packet(
 		if (peer->burst > 0)
 			peer->nextdate = current_time;
 	}
-	poll_update(peer, peer->hpoll);
 
 	/*
 	 * Verify the server is synchronized; that is, the leap bits,
@@ -1849,7 +1856,7 @@ poll_update(
 	)
 {
 	int	hpoll, minpkt;
-	u_long	next, utemp;
+	u_long	next, utemp, limit;
 
 	/*
 	 * This routine figures out when the next poll should be sent.
@@ -1900,6 +1907,15 @@ poll_update(
 	minpkt = 1 << ntp_minpkt;
 	utemp = current_time + max(peer->throttle - (NTP_SHIFT - 1) *
 	    (1 << peer->minpoll), minpkt);
+
+	/*[Bug 3592] avoid unlimited postpone of next poll */
+	limit = (2u << hpoll);
+	if (limit > 64)
+		limit -= (limit >> 2);
+	limit += peer->outdate;
+	if (limit < current_time)
+		limit = current_time;
+
 	if (peer->burst > 0) {
 		if (peer->nextdate > current_time)
 			return;
@@ -1958,6 +1974,13 @@ poll_update(
 		if (hpoll > 0)
 			peer->nextdate += minpkt;
 	}
+
+	/*[Bug 3592] avoid unlimited postpone of next poll */
+	if (peer->nextdate > limit) {
+		DPRINTF(1, ("poll_update: clamp reached; limit %lu next %lu\n",
+			    limit, peer->nextdate));
+		peer->nextdate = limit;
+	}
 #ifdef DEBUG
 	if (debug > 1)
 		printf("poll_update: at %lu %s poll %d burst %d retry %d head %d early %lu next %lu\n",
